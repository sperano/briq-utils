use convert_case::{Case, Casing};
use crate::csv::{ColorRecord, PartCategoryRecord, ThemeRecord};

const DO_NOT_EDIT: &str = "// Auto-generated by briq-utils - DO NOT EDIT";

pub fn part_categories(part_categories: &[PartCategoryRecord]) -> String {
    let mut lines = vec![
        String::from(DO_NOT_EDIT),
        String::from(""),
        String::from("enum PartCategory: Int {"),
    ];
    for cat in part_categories.iter() {
        lines.push(format!("   case {} = {}", sanitize_and_case(&cat.name), cat.id))
    }
    lines.push(String::from("}"));
    lines.join("\n")
}

pub fn colors(colors: &Vec<ColorRecord>) -> String {
    let mut lines = vec![
        String::from(DO_NOT_EDIT),
        String::from(""),
        String::from("let allColors: [PartColor] = ["),
    ];

    for color in colors {
        let y1 = if let Some(y) = color.y1 { format!("{}", y) } else { String::from("nil") };
        let y2 = if let Some(y) = color.y2 { format!("{}", y) } else { String::from("nil") };
        lines.push(format!("    PartColor(name:\"{}\", rgb: \"{}\", isTransparent: {}, partsCount: {}, setsCount: {}, year1: {}, year2: {}),",
                color.name, color.rgb, color.is_trans.to_lowercase(), color.num_parts, color.num_sets, y1, y2)); 
    }
    lines.push(String::from("];"));
    lines.join("\n")
}

#[derive(Debug, serde::Serialize)]
pub struct ThemeNode {
    pub id: u32,
    pub children: Vec<u32>, 
}

pub fn themes(themes: &Vec<ThemeRecord>) -> String {
    let mut lines = vec![
        String::from(DO_NOT_EDIT), 
        String::from("\nlet allThemes: [Theme] = ["),
    ];
    for theme in themes {
        lines.push(format!("    Theme(id: {}, name: \"{}\"),", theme.id, theme.name))
    }
    lines.push(String::from("]\n\nlet themesTree: [Theme] = ["));
    for theme in themes {
        if theme.parent_id.is_none() {
            lines.push(format!("    allThemes[{}],", theme.id));
        }
    }
    lines.push(String::from("].sorted { $0.name < $1.name };\n\nfunc initThemesTree() {"));
    for theme in themes {
        if let Some(parent_id) = theme.parent_id {
            lines.push(format!("    allThemes[{}].parent = allThemes[{}]", theme.id, parent_id));
            lines.push(format!("    allThemes[{}].children.append(allThemes[{}])", parent_id, theme.id))
        }
    }
    lines.push(String::from("}"));
    lines.join("\n")
}

// pub fn sets(sets: &Vec<Set>) -> String {
//     let mut lines = vec![
//         String::from(DO_NOT_EDIT),
//         String::from("\nlet allSets: [Set] = ["),
//     ];
//     for set in sets {
//         lines.push(format!("    Set(number: \"{}\", name: \"{}\"),", set.number, set.name.replace("\"", "\\\"")));
//     }
//     lines.push(String::from("]"));
//     lines.join("\n")
// }

pub fn sanitize_and_case(s: &str) -> String {
    let replacements = [
        ("&", " and "),
        ("!", " exclam "),
        (",", " "),
        (".", " "),
        ("'", ""),  
        ("\"", ""), 
        ("@", " at "),
        ("#", " number "),
        (":", " "),
        (";", " "),
        ("(", " "),
        (")", " "),
        ("[", " "),
        ("]", " "),
        ("{", " "),
        ("}", " "),
        ("/", " "),
        ("\\", " "),
        ("*", " "),
        ("?", " "),
    ];
    let mut cleaned = s.to_owned();
    for (from, to) in replacements {
        cleaned = cleaned.replace(from, to);
    }
    cleaned.to_case(Case::Camel)
}


